import java.util.*

plugins {
    java
    idea
    id("net.minecraftforge.gradle")
    id("org.parchmentmc.librarian.forgegradle")
}

// Variable layout matching the gradle.properties. MATCH THE ORDERING!
// Mod
val modID: String by project
val modName: String by project
val modAuthors: String by project
val modCredits: String by project
val modIssueTrackerURL: String by project
val modHomeURL: String by project
val modDescription: String by project
val modLicense: String by project
val modVersion: String by project
val modDisplayedAsResourcePack: String by project
val modDisplayedAsResourcePackBoolean: Boolean = modDisplayedAsResourcePack.toBoolean()
val modDisplayTest: String by project
val modLogoFile: String by project
val modLogoBlur: String by project
val modLogoBlurBoolean: Boolean = modLogoBlur.toBoolean()
val modUpdateURL: String by project

// Resources
val resourcesPackFormat: String by project
val resourcesDescription: String by project

// Forge
val forgeVersion: String by project

// Minecraft
val minecraftVersion: String by project

// Dev Workspace
val mappingsType: String by project
val parchmentVersion: String by project
val mappingsVersion: String = when (mappingsType) {
    "parchment" -> "${minecraftVersion}-${parchmentVersion}-${minecraftVersion}"
    else -> minecraftVersion
}
val useAdvancedClassRedef: String by project
val useAdvancedClassRedefBoolean: Boolean = useAdvancedClassRedef.toBoolean()
val ramAmountForRuns: String by project

// Computed variables not found in the gradle.properties file.
val forgeVersionRange: String = "[" + forgeVersion.substring(0, 2) + ",)"

println("Used Mappings: $mappingsType / $mappingsVersion with mod version $modVersion")

val resourcesGenerated: String = "${buildDir}/generated-resources/resources"
val modsTomlGenerated: File = file("${resourcesGenerated}/META-INF/mods.toml")
val packMetaGenerated: File = file("${resourcesGenerated}/pack.mcmeta")

// Variable validation.
if (!modID.matches("^[a-z][a-z0-9_]{1,63}\$".toRegex())) {
    throw InvalidUserDataException("Invalid modID Variable: ($modID) Must match: ^[a-z][a-z0-9_]{1,63}\$")
} else if (modID.isEmpty() or modID.isBlank())
    throw InvalidUserDataException("Missing/Empty modID Variable: ($modID)")

if (modLicense.isEmpty() or modLicense.isBlank()) {
    throw InvalidUserDataException("Missing/Empty modLicense Variable!")
}

if (modDescription.isEmpty() or modDescription.isBlank()) {
    throw InvalidUserDataException("Missing/Empty modDescription Variable!")
}

if (!arrayListOf("MATCH_VERSION", "IGNORE_SERVER_VERSION", "IGNORE_ALL_VERSION", "NONE").contains(modDisplayTest)) {
    throw InvalidUserDataException("Invalid modDisplayTest Variable: ($modDisplayTest)")
}

if (forgeVersion.isEmpty() or forgeVersion.isBlank()) {
    throw InvalidUserDataException("Missing/Empty forgeVersion Variable!")
}

base {
    archivesName.set("${modID}-forge-${minecraftVersion}")
}

java {
    toolchain.languageVersion.set(JavaLanguageVersion.of(project.properties["javaVersion"] as String))
}

repositories {
    mavenCentral()
    maven(url = "https://www.cursemaven.com") // CurseMaven
    {
        content {
            includeGroup("curse.maven")
        }
    }
    flatDir {
        dir("libs")
    }
}

dependencies {
    minecraft("net.minecraftforge", "forge", version = "$minecraftVersion-$forgeVersion")
}

sourceSets {
    main {
        resources {
            srcDir(resourcesGenerated)
        }
    }
}

tasks {
    jar {
        manifest {
            attributes["Implementation-Version"] = modVersion
        }
    }

    // Inserts the properties into whatever files.
    withType<ProcessResources>
    {
        mkdir("${resourcesGenerated}/META-INF")
        modsTomlGenerated.createNewFile()
        modsTomlGenerated.writeText(
                "# THIS FILE IS GENERATED BY THE BUILDSCRIPT DO NOT EDIT! VALUES CAN BE EDITED IN THE gradle.properties FILE!\n" +
                        "modLoader = \"javafml\"\n" +
                        "loaderVersion = \"${forgeVersionRange}\"\n" +
                        "license = \"${modLicense}\"\n" +
                        "showAsResourcePack = $modDisplayedAsResourcePackBoolean" +
                        "\n" +
                        "[[mods]]\n" +
                        "modId=\"${modID}\"\n" +
                        "version=\"${modVersion}\"\n" +
                        "displayName=\"${modName}\"\n" +
                        "issueTrackerURL=\"${modIssueTrackerURL}\"\n" +
                        "displayURL=\"${modHomeURL}\"\n" +
                        "credits=\"${modCredits}\"\n" +
                        "authors=\"${modAuthors}\"\n" +
                        "logoFile=\"${modLogoFile}\"" +
                        "logoBlur=\"${modLogoBlur}\"" +
                        "updateJSONURL=\"${modUpdateURL}\"" +
                        "description='''\n" +
                        "${modDescription}\n" +
                        "'''\n" +
                        "displayTest = \"${modDisplayTest}\""
        )

        // Find and isolate all the dependency variables following the "dep#Object" format.
        val reg = "^(dep\\d+).*\$".toRegex()
        val uniqueDep: MutableSet<String> = mutableSetOf()
        val depList: List<String> = getProperties().keys.filter { it.toLowerCase(Locale.ROOT).contains(reg) }

        // Deduplicate the "dep#" properties to get how many dependencies there are.
        depList.forEach { dep ->
            val subString: MatchResult? = reg.find(dep, 0)
            if (subString != null) {
                uniqueDep.add(subString.groupValues[1])
            }
        }
        // Validate all the data and then write each dependency.
        uniqueDep.forEach { dep ->
            val depModID: String = project.properties[dep + "ID"].toString()
            val depModMandatory: Boolean = project.properties[dep + "Mandatory"].toString().toBoolean()

            var depModOrder: String = project.properties[dep + "Order"].toString()
            var depModSide: String = project.properties[dep + "Side"].toString()

            if (depModID.isBlank() or depModID.isEmpty())
                throw InvalidUserDataException("Missing/Empty depModID Variable for $dep! This is required!")
            else if (!depModID.matches("^[a-z][a-z0-9_]{1,63}\$".toRegex())) {
                throw InvalidUserDataException("Invalid depModID Variable: ($dep=$depModID) Must match: ^[a-z][a-z0-9_]{1,63}\$")
            }

            if (depModOrder.isBlank() or depModOrder.isEmpty())
                depModOrder = "NONE"
            else if (!arrayListOf("BEFORE", "AFTER", "NONE").contains(depModOrder)) {
                throw InvalidUserDataException("Invalid depModOrder Variable: ($dep=$depModOrder)")
            }

            if (depModSide.isBlank() or depModSide.isEmpty())
                depModSide = "BOTH"
            else if (!arrayListOf("CLIENT", "SERVER", "BOTH").contains(depModSide)) {
                throw InvalidUserDataException("Invalid depModOrder Variable: ($dep=$depModSide)")
            }

            modsTomlGenerated.appendText(
                    "\n" +
                            "[[dependencies.${modID}]]\n" +
                            "    modId = \"$depModID\"\n" +
                            "    mandatory = \"$depModMandatory\"\n" +
                            "    versionRange = \"" + project.properties[dep + "VersionRange"] + "\"\n" +
                            "    ordering = \"$depModOrder\"\n" +
                            "    side = \"$depModSide\"" +
                            "\n")
        }

        if (modDisplayedAsResourcePackBoolean) {
            packMetaGenerated.createNewFile()
            packMetaGenerated.writeText("{\n" +
                    "\"__comment\": \"THIS FILE IS GENERATED BY THE BUILDSCRIPT DO NOT EDIT! VALUES CAN BE EDITED IN THE gradle.properties FILE!\",\n" +
                    "    \"pack\": {\n" +
                    "       \"pack_format\": ${resourcesPackFormat},\n" +
                    "       \"description\": \"${resourcesDescription}\"\n" +
                    "    }\n" +
                    "}")
        }

        finalizedBy("fixResourcesForFML")
    }

    // REQUIRED TO FIX https://youtrack.jetbrains.com/issue/IDEA-196103/IntelliJ-Gradle-ProcessResources-out-directory-classpath-issue
    // Can't use suggested option of change the run actions to "Use Gradle" because FML seems to require the out directory.
    register<Copy>("fixResourcesForFML")
    {
        val outFile: File = file(layout.projectDirectory.dir("out"))
        if (outFile.exists()) {
            dependsOn(processResources, compileJava, "prepareRunClient")
            from(layout.projectDirectory.dir("build/resourcesGenerated"))
            into(layout.projectDirectory.dir("out/production/resources"))
        }
    }

    register("generateSources", Copy::class) {
        from("src/main/java/")
        into("${buildDir}/generated-src")
        filesMatching("**/${modName}.java") {
            expand(mapOf("modID" to modID))
        }
    }

    compileJava {
        setSource("${buildDir}/generated-src")
        dependsOn("generateSources")
    }
}

minecraft {
    mappings(mappingsType, mappingsVersion)

    runs {
        all {

            property("forge.logging.console.level", "debug")
            property("forge.enabledGameTestNamespaces", modID)

            jvmArgs("-ea", "-Xmx$ramAmountForRuns", "-Xms$ramAmountForRuns")

            if (useAdvancedClassRedef.toBoolean()) {
                jvmArg("-XX:+AllowEnhancedClassRedefinition")
            }

            ideaModule("${modName}.test")

            mods.create(modID) {
                source(sourceSets.main.get())
            }
        }

        register("client") {
            workingDirectory("${buildDir}/run/client")
        }

        register("server") {
            workingDirectory("run/server")

            arg("--nogui")
        }

        register("gameTestServer") {
            workingDirectory("run/gametest")

            arg("--nogui")
            forceExit(false)
        }
    }
}

idea {
    module {
        for (fileName in listOf("run", "out", "logs")) {
            excludeDirs.add(file(fileName))
        }
    }
}